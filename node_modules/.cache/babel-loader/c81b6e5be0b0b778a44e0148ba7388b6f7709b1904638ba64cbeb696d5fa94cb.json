{"ast":null,"code":"import db from\"./db.js\";/////////////////////////////////////////////////////////\n////// HELPERS\n/////////////////////////////////////////////////////////\n// Splits apart the URL.\nconst getUrlParts=url=>new URL(url).pathname.split(\"/\").filter(part=>part);/*\n  Checks that the URL is valid by comparing all parts of the path to the\n  keys within the database file, or checking to ensure that it is a number.\n*/const UrlIsValid=url=>{return getUrlParts(url).every(part=>Number(part)||db.keys.includes(part));};// Retrieves data from the appropriate level.\nconst getData=url=>{const parts=getUrlParts(url);return parts.reduce((acc,part)=>{const id=Number(part);const accessor=isNaN(id)?part:id-1;return acc[accessor];},db.data);};/////////////////////////////////////////////////////////\n////// MOCK REQUEST FUNCTIONS\n/////////////////////////////////////////////////////////\nconst retrieve=url=>{const data=getData(url);if(!data){return{status:404,message:\"Not Found\",json:()=>new Promise((resolve,reject)=>{const error=new Error(`${url} not found.`);return reject(error);})};}else{return{status:200,message:\"OK\",json:()=>new Promise(resolve=>{return resolve(data);})};}};const create=(url,options)=>{const data=getData(url);const last=data[data.length-1];const body=typeof options.body===\"string\"?JSON.parse(options.body):options.body;const newRecord={id:last?last.id+1:1,...body};data.push(newRecord);return{status:201,message:\"Created\",json:()=>new Promise(resolve=>{resolve(newRecord);})};};const update=(url,options)=>{const data=getData(url);const body=typeof options.body===\"string\"?JSON.parse(options.body):options.body;for(let key in body){if(key!==\"id\"){data[key]=body[key];}}return{status:201,message:\"Created\",json:()=>new Promise(resolve=>{resolve(data);})};};const destroy=url=>{const parts=getUrlParts(url);const id=Number(parts[parts.length-1]);const parentPath=[\"http://mockhost\",...parts.slice(0,-1)].join(\"/\");const data=getData(parentPath);const index=data.findIndex(resource=>resource.id===id);data.splice(index,1);return{status:200,message:\"OK\",json:()=>{new Promise(resolve=>resolve({id}));}};};const MOCK_REQUEST_METHODS={GET:retrieve,POST:create,PUT:update,DELETE:destroy};const generateMockRequest=function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const fn=MOCK_REQUEST_METHODS[options.method]||MOCK_REQUEST_METHODS.GET;return fn(url,options);};/////////////////////////////////////////////////////////\n////// MOCK REQUEST FUNCTIONS\n/////////////////////////////////////////////////////////\n// Store local version of fetch.\nlet typicalFetch;try{typicalFetch=fetch;}catch(error){typicalFetch=()=>{};}// Reassign fetch if the URL path includes 'mockhost'\nglobal.fetch=(url,options)=>{if(url.match(/http(s?):\\/\\/mockhost/i)){return new Promise((resolve,reject)=>{if(UrlIsValid(url)){const response=generateMockRequest(url,options);return resolve(response);}else{return reject({status:500,message:\"Internal server error\"});}});}else{return typicalFetch(url,options);}};export default global.fetch;","map":{"version":3,"names":["db","getUrlParts","url","URL","pathname","split","filter","part","UrlIsValid","every","Number","keys","includes","getData","parts","reduce","acc","id","accessor","isNaN","data","retrieve","status","message","json","Promise","resolve","reject","error","Error","create","options","last","length","body","JSON","parse","newRecord","push","update","key","destroy","parentPath","slice","join","index","findIndex","resource","splice","MOCK_REQUEST_METHODS","GET","POST","PUT","DELETE","generateMockRequest","arguments","undefined","fn","method","typicalFetch","fetch","global","match","response"],"sources":["/Users/ahhyan/Chegg/flipcard-capstone-project/src/util/fetch.js"],"sourcesContent":["import db from \"./db.js\";\n\n/////////////////////////////////////////////////////////\n////// HELPERS\n/////////////////////////////////////////////////////////\n\n// Splits apart the URL.\nconst getUrlParts = (url) =>\n  new URL(url).pathname.split(\"/\").filter((part) => part);\n\n/*\n  Checks that the URL is valid by comparing all parts of the path to the\n  keys within the database file, or checking to ensure that it is a number.\n*/\nconst UrlIsValid = (url) => {\n  return getUrlParts(url).every(\n    (part) => Number(part) || db.keys.includes(part)\n  );\n};\n\n// Retrieves data from the appropriate level.\nconst getData = (url) => {\n  const parts = getUrlParts(url);\n  return parts.reduce((acc, part) => {\n    const id = Number(part);\n    const accessor = isNaN(id) ? part : id - 1;\n    return acc[accessor];\n  }, db.data);\n};\n\n/////////////////////////////////////////////////////////\n////// MOCK REQUEST FUNCTIONS\n/////////////////////////////////////////////////////////\n\nconst retrieve = (url) => {\n  const data = getData(url);\n  if (!data) {\n    return {\n      status: 404,\n      message: \"Not Found\",\n      json: () =>\n        new Promise((resolve, reject) => {\n          const error = new Error(`${url} not found.`);\n          return reject(error);\n        }),\n    };\n  } else {\n    return {\n      status: 200,\n      message: \"OK\",\n      json: () =>\n        new Promise((resolve) => {\n          return resolve(data);\n        }),\n    };\n  }\n};\n\nconst create = (url, options) => {\n  const data = getData(url);\n  const last = data[data.length - 1];\n  const body =\n    typeof options.body === \"string\" ? JSON.parse(options.body) : options.body;\n  const newRecord = {\n    id: last ? last.id + 1 : 1,\n    ...body,\n  };\n\n  data.push(newRecord);\n\n  return {\n    status: 201,\n    message: \"Created\",\n    json: () =>\n      new Promise((resolve) => {\n        resolve(newRecord);\n      }),\n  };\n};\n\nconst update = (url, options) => {\n  const data = getData(url);\n  const body =\n    typeof options.body === \"string\" ? JSON.parse(options.body) : options.body;\n\n  for (let key in body) {\n    if (key !== \"id\") {\n      data[key] = body[key];\n    }\n  }\n\n  return {\n    status: 201,\n    message: \"Created\",\n    json: () =>\n      new Promise((resolve) => {\n        resolve(data);\n      }),\n  };\n};\n\nconst destroy = (url) => {\n  const parts = getUrlParts(url);\n  const id = Number(parts[parts.length - 1]);\n  const parentPath = [\"http://mockhost\", ...parts.slice(0, -1)].join(\"/\");\n  const data = getData(parentPath);\n\n  const index = data.findIndex((resource) => resource.id === id);\n  data.splice(index, 1);\n\n  return {\n    status: 200,\n    message: \"OK\",\n    json: () => {\n      new Promise((resolve) => resolve({ id }));\n    },\n  };\n};\n\nconst MOCK_REQUEST_METHODS = {\n  GET: retrieve,\n  POST: create,\n  PUT: update,\n  DELETE: destroy,\n};\n\nconst generateMockRequest = (url, options = {}) => {\n  const fn = MOCK_REQUEST_METHODS[options.method] || MOCK_REQUEST_METHODS.GET;\n  return fn(url, options);\n};\n\n/////////////////////////////////////////////////////////\n////// MOCK REQUEST FUNCTIONS\n/////////////////////////////////////////////////////////\n\n// Store local version of fetch.\nlet typicalFetch;\ntry {\n  typicalFetch = fetch;\n} catch (error) {\n  typicalFetch = () => {};\n}\n\n// Reassign fetch if the URL path includes 'mockhost'\nglobal.fetch = (url, options) => {\n  if (url.match(/http(s?):\\/\\/mockhost/i)) {\n    return new Promise((resolve, reject) => {\n      if (UrlIsValid(url)) {\n        const response = generateMockRequest(url, options);\n        return resolve(response);\n      } else {\n        return reject({ status: 500, message: \"Internal server error\" });\n      }\n    });\n  } else {\n    return typicalFetch(url, options);\n  }\n};\n\nexport default global.fetch;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}